parent_classes:


  - class: AllegroFlare::Screens::Gameplay
    scope: public
    init_with: ''


properties:


  - name: data_folder_path
    type: std::string
    init_with: '"[unset-data_folder_path]"'
    getter: true
    setter: true

  - name: audio_controller
    type: AllegroFlare::AudioController*
    init_with: nullptr
    getter: true
    setter: true

  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: before_initialized

  - name: dialog_system
    type: AllegroFlare::DialogSystem::DialogSystem*
    init_with: nullptr
    getter: true
    setter: before_initialized

  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: before_initialized

  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: before_initialized

  - name: model_bin
    type: AllegroFlare::ModelBin*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: before_initialized

  - name: game_configuration
    type: AllegroFlare::GameConfigurations::Base*
    xtype: Krampus24::Game::Configurations::Main*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: true

  - name: hud_camera
    type: AllegroFlare::Camera2D
    init_with: '{}'
    getter: true
    setter: true

  - name: player_view_camera
    type: AllegroFlare::Camera3D
    init_with: '{}'
    getter: true
    setter: true

  - name: live_camera
    type: AllegroFlare::Camera3D
    init_with: '{}'
    getter: true
    setter: true

  - name: target_camera
    type: AllegroFlare::Camera3D
    init_with: '{}'
    getter: true
    setter: true

  - name: player_spin
    type: float
    init_with: 0.0f
    getter: true
    setter: true

  - name: entities
    type: std::vector<Krampus24::Gameplay::Entities::Base*>
    init_with: '{}'
    constructor_arg: true
    getter: true
    getter_ref: true
    setter: true

  - name: collision_mesh
    type: AllegroFlare::Physics::CollisionMesh*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: true

  - name: visual_mesh
    type: AllegroFlare::Model3D*
    init_with: nullptr
    getter: true
    setter: true

  - name: player_spawn_position
    type: AllegroFlare::Vec3D
    init_with: AllegroFlare::Vec3D(0, 0, 0)
    getter: true
    setter: true

  - name: collision_mesh_identifier
    type: std::string
    init_with: '"tree-0x-collision_mesh.obj"'
    constructor_arg: true
    getter: true
    setter: before_initialized

  - name: visual_mesh_identifier
    type: std::string
    init_with: '"tree-0x-visual.obj"'
    constructor_arg: true
    getter: true
    setter: before_initialized

  - name: visual_mesh_texture_identifier
    type: std::string
    init_with: '"RETRO_TEXTURE_PACK_V15-atlas-01.png"'
    constructor_arg: true
    getter: true
    setter: before_initialized

  - name: blocking_filename
    type: std::string
    init_with: '"tree-0x.blocking"'
    constructor_arg: true
    getter: true
    setter: before_initialized

  - name: scripting
    type: Krampus24::Gameplay::ScriptingInterface*
    init_with: nullptr

  - name: build_scripting_instance_func
    type: std::function<Krampus24::Gameplay::ScriptingInterface*(Krampus24::Gameplay::Screen*)>
    init_with: '{}'
    getter: true
    setter: true

  - name: current_location_name
    type: std::string
    init_with: '""'

  - name: current_location_floor
    type: std::string
    init_with: '""'

  - name: current_location_reveal_counter
    type: float
    init_with: 0.0f

  - name: principled_shader
    type: Krampus24::Shaders::Principled
    init_with: '{}'

  - name: rendering_visual_mesh
    type: bool
    init_with: true

  - name: rendering_collision_wiremesh
    type: bool
    init_with: false

  - name: rendering_entity_models
    type: bool
    init_with: true

  - name: rendering_entity_bounding_boxes
    type: bool
    init_with: false

  - name: showing_inspect_hint
    type: bool
    init_with: false

  - name: dev__str_1
    type: std::string
    init_with: '"[unset-def__str_1]"'

  - name: dev__float_1
    type: float
    init_with: 0.0f

  - name: dev__float_2
    type: float
    init_with: 0.0f

  - name: dev__float_3
    type: float
    init_with: 0.0f

  - name: dev__float_4
    type: float
    init_with: 0.0f

  - name: dev__bool_1
    type: bool
    init_with: false

  - name: collision_observer
    type: AllegroFlare::CollisionObservers::Simple
    init_with: '{}'
    getter_ref: true

  - name: inspectable_entity_that_player_is_currently_colliding_with
    type: Krampus24::Gameplay::Entities::Base*
    init_with: nullptr
    getter: true
    setter: true

  - name: initialized
    type: bool
    init_with: false
    getter: true


methods:


  - name: initialize
    guards:
      - (!initialized)
      - al_is_system_installed()
      - al_is_primitives_addon_initialized()
      - al_is_font_addon_initialized()
      - dialog_system
      - audio_controller
      - event_emitter
      - bitmap_bin
      - font_bin
      - model_bin
    body: |
      set_update_strategy(AllegroFlare::Screens::Base::UpdateStrategy::SEPARATE_UPDATE_AND_RENDER_FUNCS);

      //live_camera.stepout = AllegroFlare::Vec3D(0, 1.25, 0); // FPS camera
      live_camera.stepout = AllegroFlare::Vec3D(0, 2.25, 0); // FPS camera
      live_camera.tilt = 0.0;
      live_camera.near_plane = 0.25;   // Variables are: camera near_plane, collision_mesh face offset amount, extra collision stepout, 
      live_camera.far_plane = 500.0;

      player_view_camera = live_camera;

      //live_camera.stepout = AllegroFlare::Vec3D(0, 0.25, 10); // Third person
      //live_camera.tilt = 0.8;

      // Set this levels entities to the scripting logic
      //Krampus24::Game::Scripting::Tree *tree_scripting = new Krampus24::Game::Scripting::Tree;
      //tree_scripting.set_entities(&entities);
      //tree_scripting.set_collision_observer(&collision_observer);
      //tree_scripting.set_font_bin(font_bin);
      //tree_scripting.initialize();

      //scripting = tree_scripting;

      // Setup dialog system styling
      setup_dialog_system_styling();

      // Load level and entities
      load_or_reload_meshes();

      // Create a player input controller for the 0th entity
      create_and_set_player_input_controller_for_0th_entity();

      principled_shader.initialize();
      principled_shader.set_fog_color(al_color_html("#31687a"));
      principled_shader.set_fog_intensity(0.9);
      principled_shader.set_fog_distance(40.0);

      principled_shader.set_world_tint(ALLEGRO_COLOR{0.3, 0.3, 0.4, 1.0});

      initialized = true;
      return;
    body_dependency_symbols:
      - al_is_primitives_addon_initialized
      - Krampus24::Game::Scripting::Tree
      - al_color_html


  - name: setup_dialog_system_styling
    body: |
      //dialog_system->set_standard_dialog_box_font_name("Orbitron-Medium.ttf");

      dialog_system->set_standard_dialog_box_font_name("Exan-Regular.ttf");
      dialog_system->set_standard_dialog_box_font_size(
         AllegroFlare::DialogSystem::DialogSystem::DEFAULT_STANDARD_DIALOG_BOX_FONT_SIZE - 8
      );
      return;


  - name: create_entity
    type: std::vector<Krampus24::Gameplay::Entities::Base*>
    virtual: true
    parameters:
      - name: blender_blocking_entity
        type: Krampus24::BlenderBlockingLoaderEntity*
        default_argument: nullptr
    guards: [ blender_blocking_entity ]
    body: |
      // TODO: Find a way to move this method into a... Game/ class possibly?
      Krampus24::Game::EntityFactory factory;
      factory.set_event_emitter(event_emitter);
      //factory.set_font_bin(font_bin);
      factory.set_model_bin(model_bin);
      factory.set_bitmap_bin(bitmap_bin);
      factory.set_collision_mesh(collision_mesh);
      factory.initialize();
      return factory.create_entity(blender_blocking_entity);
    body_dependency_symbols:
      - Krampus24::Game::EntityFactory


  - name: load_or_reload_meshes
    body: |
      player_spawn_position = {4.0, 0.001, 3.5}; // DEVELOPMENT
      float player_initial_spin = ALLEGRO_PI * -0.25;
      //AllegroFlare::Vec3D restored_player_position = player_spawn_position;
      Krampus24::Gameplay::Entities::Base* existing_player_entity = nullptr;
      if (a_0th_entity_exists()) existing_player_entity = find_0th_entity();
      //if (existing_player_entity);




      // Load the collision mesh
      if (collision_mesh)
      {

         model_bin->destroy(collision_mesh_identifier);
         collision_mesh = nullptr;
      }
      collision_mesh = new AllegroFlare::Physics::CollisionMesh();
      collision_mesh->set_model(model_bin->operator[](collision_mesh_identifier));
      collision_mesh->load();

      // Load the visual mesh
      if (visual_mesh)
      {
         model_bin->destroy(visual_mesh_identifier);
         visual_mesh = nullptr;
      }
      visual_mesh = model_bin->operator[](visual_mesh_identifier);
      visual_mesh->set_texture(bitmap_bin->operator[](visual_mesh_texture_identifier));




      // Load the blocking file
      // Delete all entities (except the existing player entity)
      for (auto &entity : entities)
      {
         if (entity == existing_player_entity) continue; // Skip the player entity if it already exists
         delete entity; // Hmm, good luck here
      }

      // Clear the entities (Will re-add the player if it had previously existed)
      entities.clear();
      collision_observer.clear(); // Clear any current collisions, and the subject
      inspectable_entity_that_player_is_currently_colliding_with = nullptr; // TODO: Consider side effects of releasing
                                                                            // the current colliding entity here
      if (showing_inspect_hint) hide_inspect_hint();

      // Create the 0th entity (the player)
      if (existing_player_entity)
      {
         entities.push_back(existing_player_entity);
      }
      else
      {
         Krampus24::Gameplay::Entities::Base* player_entity =
            new Krampus24::Gameplay::Entities::Base();
         player_entity->placement.size = {0.5, 0.5, 0.5};
         player_entity->aabb3d.set_max(player_entity->placement.size);
         player_entity->aabb3d_alignment = { 0.5, 0.05, 0.5 };
         player_entity->placement.position = player_spawn_position;
         player_entity->player__spin = player_initial_spin;
         entities.push_back(player_entity);
      }
      // Create entities from the blocking file
      std::string blocking_file_full_path = data_folder_path + "maps/" + blocking_filename;
      Krampus24::BlenderBlockingLoader blender_blocking_loader(blocking_file_full_path);
      blender_blocking_loader.load();
      blender_blocking_loader.for_each_entity([this, existing_player_entity](Krampus24::BlenderBlockingLoaderEntity* entity){
         //float x = entity->location.x;
         //float y = entity->location.z; // Swapping z<->y
         //float z = entity->location.y; // Swapping z<->y

         std::string entity_root_name = entity->get_name_unversioned();
         if (entity_root_name == "player_spawn")
         {
            float x = entity->location.x;
            float y = entity->location.z; // Swapping z<->y
            float z = entity->location.y; // Swapping z<->y

            AllegroFlare::Vec3D position = AllegroFlare::Vec3D(x, y, z);

            //Krampus24::Gameplay::Entities::Base* player_entity = find_0th_entity();
            player_spawn_position = position;
            //player_entity->placement.position = player_spawn_position; // + AllegroFlare::Vec3D(0, 0.01, 0);
            //float rotation = entity->rotation.z / 360.0;
            //auto *result = Krampus24::Gameplay::Entities::Turret::construct(model_bin, bitmap_bin, position, rotation);
            //result->name = entity->name;
            //return result;
            if (!existing_player_entity)
            {
               Krampus24::Gameplay::Entities::Base* player_entity = find_0th_entity();
               player_entity->placement.position = player_spawn_position;
               float rotation = ALLEGRO_PI * 1.0; // NOTE: This value is not extracted from the entity, and is
                                                  // hard-coded here.
               player_entity->player__spin = rotation; //player_spawn_position; // HERE
            }
         }
         else
         {
            //std::vector<Krampus24::Gameplay::Entities::Base*> result_entities = scripting->create_entity(entity);
            std::vector<Krampus24::Gameplay::Entities::Base*> result_entities = create_entity(entity);
            for (auto &result_entity : result_entities)
            {
               entities.push_back(result_entity);
            }
         }
      });
      blender_blocking_loader.for_each_zone([this](Krampus24::BlenderBlockingLoaderBlock* zone){
         //std::string zone_root_name = zone->get_name_unversioned();

         //if (zone_root_name == Krampus24::Gameplay::Entities::Zone::BLENDER_IDENTIFIER)
         //{
            //float x = entity->location.x;
            //float y = entity->location.z; // Swapping z<->y
            //float z = entity->location.y; // Swapping z<->y
            AllegroFlare::Vec3D position = AllegroFlare::Vec3D(
               zone->min_coordinates.x,
               zone->min_coordinates.z,
               zone->min_coordinates.y
            );

            AllegroFlare::Vec3D natural_size = zone->calculate_size();
            AllegroFlare::Vec3D size = AllegroFlare::Vec3D(
               natural_size.x,
               natural_size.z,
               natural_size.y
            );

            //float x = entity->location.x;
            //float y = entity->location.z; // Swapping z<->y
            //float z = entity->location.y; // Swapping z<->y
            //AllegroFlare::Vec3D position = AllegroFlare::Vec3D(x, y, z);

            //float rotation = entity->rotation.z / 360.0;
            //AllegroFlare::Vec3D size = entity->size;
            auto *result = Krampus24::Gameplay::Entities::Zone::construct(position, size);
            result->name = zone->name;
            //return { result };
            entities.push_back(result);
         //}
      });



      // Load up the sound effects // DEVELOPMENT
      // TODO: Move this to another more appropriate location
      audio_controller->set_and_load_sound_effect_elements(
         Krampus24::Gameplay::Entities::Door::build_audio_controller_sound_effect_list()
      );
      

      // Load up the scripting
      if (scripting)
      {
         delete scripting;
         scripting = nullptr;
      }


      if (build_scripting_instance_func)
      {
         //std::cout << "---- Building scripting ----" << std::endl;
         scripting = build_scripting_instance_func(this);
         if (!scripting)
         {
            AllegroFlare::Logger::throw_error(
               "Krampus24::Gameplay::Screen::load_or_reload_meshes",
               "When calling the provided \"build_scripting_interface_func\", a nullptr was returned."
            );
         }
      }
      else
      {
         // TODO: Output warning
         AllegroFlare::Logger::warn_from(
            "Krampus24::Gameplay::Screen::load_or_reload_meshes",
            "When loading, there was no \"build_scripting_interface_func\" provided. A generic Empty class will be "
               "used."
         );
         scripting = new Krampus24::Gameplay::Scripting::Empty();
      }


      //Krampus24::Game::Scripting::Tree *tree_scripting = new Krampus24::Game::Scripting::Tree;
      //tree_scripting->set_entities(&entities);
      //tree_scripting->set_collision_observer(&collision_observer);
      //tree_scripting->set_font_bin(font_bin);
      //tree_scripting->initialize();
      //scripting = tree_scripting


      //scripting.build_on_collision_callbacks();

      return;
    body_dependency_symbols:
      - Krampus24::BlenderBlockingLoader
      - Krampus24::Gameplay::Scripting::Empty
      - Krampus24::Gameplay::Entities::Zone
      - AllegroFlare::Logger


  - name: ~destruct
    body: |
      // TODO: Destroy meshes (which should now be owned by this class)
      // TODO: Destroy visual mesh bitmap (which should now be owned by this class)
      return;


  - name: on_activate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      //emit_event_to_update_input_hints_bar();
      //emit_show_and_size_input_hints_bar_event();
      return;


  - name: on_deactivate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      //emit_hide_and_restore_size_input_hints_bar_event();
      return;


  - name: gameplay_suspend_func
    virtual: true
    override: true
    body: |
      //gameplay_suspended_at = al_get_time();
      //AllegroFlare::Screens::Gameplay::gameplay_suspend_func(); // Should this be here?
      //if (player_input_controller_exists())
      //{
         //AllegroFlare::Logger::warn_from(
               //"AllegroFlare::Prototypes::TileFPS::Screen::gameplay_suspend_func",
               //"This method requires attention. Currently there is little to no support for player_input_controller "
                  //"handling gameplay_suspend_func()"
            //);
         //here__get_player_input_controller()->gameplay_suspend_func();
      //}
      //player_stop_moving();
      // NOTE: This function is called immediately after the gameplay is suspended.
      // TODO: Consider setting states on entities, checking their state timers, etc
      return;


  - name: gameplay_resume_func
    virtual: true
    override: true
    body: |
      //AllegroFlare::Screens::Gameplay::gameplay_resume_func();

      //if (player_input_controller_exists())
      //{
         //AllegroFlare::Logger::warn_from(
               //"AllegroFlare::Prototypes::TileFPS::Screen::gameplay_suspend_func",
               //"This method requires attention. Currently there is little to no support for player_input_controller "
                  //"handling gameplay_resume_func()"
            //);
         //here__get_player_input_controller()->gameplay_resume_func();
      //}
      //player_stop_moving();
      // NOTE: This function is called immediately after the gameplay is resumed.
      // TODO: Consider reviewing states on entities, reviewing their state timers, etc.
      return;

      // Keyboard changes that occurred during the gameplay
      AllegroFlare::SuspendedKeyboardState &suspended_keyboard_state = get_suspended_keyboard_state_ref();
      std::vector<uint32_t> keys_pressed = suspended_keyboard_state.get_keys_pressed();
      std::vector<uint32_t> keys_released = suspended_keyboard_state.get_keys_released();
      float time_now = al_get_time(); // TODO: Inject time when the resume occurred

      //auto entity_control_connector = get_entity_control_connector();
      //if (entity_control_connector)
      //{
         //if (entity_control_connector->is_type(SomePlatformer::EntityControlConnectors::PlayerCharacter::TYPE))
         //{
            // In this techniqe, we'll build a fake ALLEGRO_EVENT and pass it into the entity_control_connector.
            // There could potentially be unidentified side effects with this approach, some example:
            //   1) This event does not pass through the normal global event queue.
            //   2) The "source" and "display" fields are not used in this event, but may need to be present at
            //      some point
            //   3) The control connector may be expecting a full pass of the event through the system before
            //      processing a second "event".
            // Advantage of this approach is that the base class takes key_up_func and key_down_func, so this
            // technique could be used on all EntityControlConnectors::Base classes.

            // Process key releases (a.k.a. "key up")
            //for (auto &key_released : keys_released)
            //{
               //ALLEGRO_EVENT event;
               //event.type = ALLEGRO_EVENT_KEY_UP;
               //event.any.source = nullptr; // TODO: Should I be using a SuspendedKeyboardState event source?
               //event.any.timestamp = time_now;
               //event.keyboard.keycode = key_released;
               //event.keyboard.display = nullptr; // TODO: Consider if al_get_current_display() should be used here

               //entity_control_connector->key_up_func(&event);
            //}

            // Process key presses (a.k.a. "key down")
            //for (auto &key_pressed : keys_pressed)
            //{
               //ALLEGRO_EVENT event;
               //event.type = ALLEGRO_EVENT_KEY_DOWN;
               //event.any.source = nullptr; // TODO: Should I be using a SuspendedKeyboardState event source?
               //event.any.timestamp = time_now;
               //event.keyboard.keycode = key_pressed;
               //event.keyboard.display = nullptr; // TODO: Consider if al_get_current_display() should be used here

               //entity_control_connector->key_down_func(&event);
            //}
         //}
      //}
      return;




  - name: load_or_reload_level_mesh
    body: |
      return;


  - name: a_0th_entity_exists
    type: bool
    body: |
      return (entities.size() > 0);


  - name: find_0th_entity
    type: Krampus24::Gameplay::Entities::Base*
    guards: [ (entities.size() > 0) ]
    body: |
      return entities.at(0);


  - name: create_and_set_player_input_controller_for_0th_entity
    body: |
      Krampus24::Gameplay::PlayerInputControllers::Player *result_player_input_controller = new
         Krampus24::Gameplay::PlayerInputControllers::Player();
      result_player_input_controller->set_player_entity(find_0th_entity());
      result_player_input_controller->set_move_multiplier(0.0875); // 0.1 is running, 0.5 is walking (slowly)
      result_player_input_controller->initialize();

      set_player_input_controller(result_player_input_controller);

      return;




      /*
      AllegroFlare::PlayerInputControllers::Generic *result_player_input_controller =
         new AllegroFlare::PlayerInputControllers::Generic();

      result_player_input_controller->set_on_time_step_update([this](AllegroFlare::Vec2D control_movement, double, double){
         //find_0th_entity()->get_velocity_ref().position.x = pos.x * 0.1;
         //find_0th_entity()->get_velocity_ref().position.z = pos.y * 0.1;
         //bool moving_forward = false;
         //bool moving_backward = false;
         //bool moving_right = false;
         //bool moving_left = false;

         //control_movement = pos;
         //if (moving_forward) control_movement.y = -1;
         //if (moving_backward) control_movement.y = 1;
         //if (moving_right) control_movement.x = 1;
         //if (moving_left) control_movement.x = -1;

         auto entity = find_0th_entity();

         // Relative to camera:
         float angle = player_spin;
         //float angle = live_camera.spin;
         float x_prime = control_movement.x * std::cos(angle) - control_movement.y * std::sin(angle);
         float y_prime = control_movement.x * std::sin(angle) + control_movement.y * std::cos(angle);
         entity->velocity.position.x = x_prime * 0.1;
         entity->velocity.position.z = y_prime * 0.1;
      });

      set_player_input_controller(result_player_input_controller);
      */
      return;
    body_dependency_symbols:
       - AllegroFlare::PlayerInputControllers::Generic
       - Krampus24::Gameplay::PlayerInputControllers::Player


  - name: create_arbitrary_storyboard_pages_by_identifier
    type: std::vector<AllegroFlare::Elements::StoryboardPages::Base *>
    guards: [ font_bin, scripting ]
    body: |
      return scripting->create_arbitrary_storyboard_pages_by_identifier();


  - name: interact_with_focused_inspectable_object
    body: |
      //spawn_arbitrary_storyboard_screen("pig_storyboard");

      if (inspectable_entity_that_player_is_currently_colliding_with)
      {
         // Perform the entities local reaction to inspection
         bool entity_scoped_inspection_occurred =
            inspectable_entity_that_player_is_currently_colliding_with->on_player_inspect_or_use();

         // TODO: Perform the scripting's inspection logic
         bool scripting_scoped_inspection_occurred = false;
         //if (!entity_scoped_inspection_occurred) // TODO: Consider if a guard here is desired or not
         {
            scripting->interact_with_focused_object(inspectable_entity_that_player_is_currently_colliding_with);
         }

         // If no inspection happened, play a "no inspection sound"
         if (!entity_scoped_inspection_occurred || scripting_scoped_inspection_occurred)
         {
            // TODO: Play "no inspection" sound
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Routers::Standard


  - name: hide_inspect_hint
    body: |
      showing_inspect_hint = false;
      return;


  - name: show_inspect_hint
    body: |
      showing_inspect_hint = true;
      return;


  - name: is_player_looking_at_object
    type: bool
    parameters:
      - name: player_position
        type: AllegroFlare::Vec3D
        default_argument: '{}'
      - name: player_forward
        type: AllegroFlare::Vec3D
        default_argument: '{}'
      - name: object_position
        type: AllegroFlare::Vec3D
        default_argument: '{}'
      - name: angle_threshold_degrees
        type: float
        default_argument: 0.25
    body: |
      // Check if the player is looking at an object
      //bool is_player_looking_at_object(const Vector3 &player_position,
                                       //const Vector3 &player_forward,
                                       //const Vector3 &object_position,
                                       //float angle_threshold_degrees)
      {
         // Vector pointing from player to object
         AllegroFlare::Vec3D to_object = object_position - player_position;
         AllegroFlare::Vec3D to_object_normalized = to_object.normalized();

         // Normalize the player's forward vector
         AllegroFlare::Vec3D player_forward_normalized = player_forward.normalized();

         // Calculate the dot product
         float dot_product = player_forward_normalized * to_object_normalized;
         //float dot_product = player_forward_normalized.dot_product(to_object_normalized);

         // Convert angle threshold to radians
         float angle_threshold_radians = angle_threshold_degrees * (M_PI / 180.0f);

         // Calculate the cosine of the threshold angle
         float cos_threshold = std::cos(angle_threshold_radians);

         // If the dot product is greater than the cosine of the threshold angle,
         // the object is within the player's field of view
         return dot_product >= cos_threshold;
      }


  - name: player_view_dot_product_to_entity
    type: float
    parameters:
      - name: player_view_position
        type: AllegroFlare::Vec3D
        default_argument: '{}'
      - name: player_look_vector
        type: AllegroFlare::Vec3D
        default_argument: '{}'
      - name: object_position
        type: AllegroFlare::Vec3D
        default_argument: '{}'
    body: |
      // Get tablet entity
      //AllegroFlare::Vec3D player_view_position = player_view_camera.get_real_position();
      //AllegroFlare::Vec3D player_look_vector = player_view_camera.get_viewing_direction();

      // Calculate the vector pointing to the object
      AllegroFlare::Vec3D object_vector = player_view_position - object_position;
      //AllegroFlare::Vec3D object_vector = object_position - player_view_position;

      // Normalize both vectors
      AllegroFlare::Vec3D normalized_object_vector = object_vector.normalized();
      AllegroFlare::Vec3D normalized_player_look_vector = player_look_vector.normalized();

      // Compute the dot product
      float dot_product = normalized_player_look_vector * normalized_object_vector;

      // Return the alignment
      return dot_product;


  - name: update_inspectable_entity_that_player_is_currently_colliding_with
    body: |
      auto player_entity = find_0th_entity();
      if (!player_entity) throw std::runtime_error("asjiodfasjdiofajsdiofasjdifoajsdiofjadsoi");

      Krampus24::Gameplay::Entities::Base *found_colliding_entity = nullptr;
      for (auto &entity : entities)
      {
         if (!entity->active) continue;
         if (entity == player_entity) continue;
         if (!entity->player_can_inspect_or_use) continue; // NOTE: In this case, the entity does not need a
                                                           // collides with player flag in order for inspect feature
                                                           // to work.
         if (entity->collides_aabb3d(player_entity)) 
         {
            AllegroFlare::Vec3D player_view_position = player_view_camera.position;
            //AllegroFlare::Vec3D player_view_position = player_view_camera.get_real_position();
            AllegroFlare::Vec3D player_look_vector = player_view_camera.get_viewing_direction();
            //AllegroFlare::Vec3D entity_position = entity->placement.position;
            //AllegroFlare::Vec3D entity_position = entity->placement.position;
            AllegroFlare::Vec3D entity_position = entity->calculate_centroid(); // HERE

            float dot_product_to_entity = player_view_dot_product_to_entity(
               player_view_position,
               player_look_vector,
               entity_position
            );

            bool is_looking_at_entity = -dot_product_to_entity > 0.9;

            dev__str_1 = entity->name;
            dev__float_1 = dot_product_to_entity;
            dev__float_2 = std::abs(dot_product_to_entity);
            dev__float_3 = AllegroFlare::distance(entity->placement.position, player_entity->placement.position);
            dev__float_4 = AllegroFlare::distance(entity->placement.position, player_view_position);
            dev__bool_1 = is_looking_at_entity;

            if (!is_looking_at_entity) continue;

            //if (!player_is_looking_at_object) continue; // TODO: bring in calculation

            found_colliding_entity = entity;
            break;
         }
      }

      if (found_colliding_entity != inspectable_entity_that_player_is_currently_colliding_with)
      {
         // Assign the found entity to be the colliding one
         inspectable_entity_that_player_is_currently_colliding_with = found_colliding_entity;

         // TODO: Some feedback that a new collision occurred (a sound effect for example)
         if (inspectable_entity_that_player_is_currently_colliding_with == nullptr)
         {
            hide_inspect_hint();
         }
         else
         {
            show_inspect_hint();
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::distance


  - name: show_location_name
    parameters:
      - name: location_name
        type: std::string
        default_argument: '"[unset-location_name]"'
      - name: location_floor
        type: std::string
        default_argument: '"[unset-location_floor]"'
    body: |
      if (this->current_location_name == location_name && this->current_location_floor == location_floor) return;
      this->current_location_name = location_name;
      this->current_location_floor = location_floor;

      current_location_reveal_counter = 0.0f;
      return;


  - name: update
    body: |
      float time_now = al_get_time();
      float step_duration = 1.0f;


      current_location_reveal_counter += (1.0 / 60.0);
      if (current_location_reveal_counter > 10.0) current_location_reveal_counter = 10.0;
      


      // Step each entity via its update function
      for (auto &entity : entities)
      {
         if (!entity->active) continue;
         entity->on_time_step(step_duration, time_now); // Should this be al_get_time or a globally tracked time now?
      }
      

      //
      // Apply environmental forces (gravity, air drag)
      //

      float gravity = AllegroFlare::Physics::CollisionMeshCollisionStepper::DEFAULT_GRAVITY;
      float air_drag = AllegroFlare::Physics::CollisionMeshCollisionStepper::DEFAULT_AIR_DRAG;
      AllegroFlare::Vec3D velocity_direction = AllegroFlare::Vec3D(0.0f, 1.0f, 0.0f).normalized();

      for (auto &entity : entities)
      {
         if (!entity->active || !entity->affected_by_environmental_forces) continue;

         entity->velocity.position += velocity_direction * gravity * step_duration;
         entity->velocity.position *= (1.0 - air_drag);
      }
      

      //
      // Step entities
      //

      // Build the entities list to be stepped by the stepper
      std::vector<std::tuple<AllegroFlare::Vec3D*, AllegroFlare::Vec3D*, void*>>
         collision_stepper_entities;
      collision_stepper_entities.reserve(entities.size());
      for (auto &entity : entities)
      {
         if (!entity->active || !entity->collides_with_environment) continue;

         collision_stepper_entities.push_back(std::make_tuple(
            &entity->placement.position,
            &entity->velocity.position,
            (void*)entity
         ));
      }

      if (collision_stepper_entities.empty()) throw std::runtime_error("asdfasdf");

      AllegroFlare::Physics::CollisionMeshCollisionStepper stepper;
      stepper.set_collision_mesh(collision_mesh);
      stepper.set__entities(&collision_stepper_entities);
      stepper.disable_applying_environmental_forces();
      stepper.step(step_duration);


      //
      // Reposition the player vertically if they are attached to an elevator
      //
      {
         auto player_entity = find_0th_entity();
         if (player_entity->is_attached_to_elevator())
         {
            Krampus24::Gameplay::Entities::Base* elevator = player_entity->elevator_entity_attached_to;
            Krampus24::Gameplay::Entities::ElevatorShaft* as =
               static_cast<Krampus24::Gameplay::Entities::ElevatorShaft*>(elevator);
            player_entity->placement.position.y = as->calculate_global_elevator_car_y_position();
            player_entity->velocity.position.y = 0.0;
         }
      }


      //
      // Observe change in entity<->entity collisions
      //
      {
         std::set<void*> collidables;
         auto player_entity = find_0th_entity();
         for (auto &entity : entities)
         {
            if (entity == player_entity) continue;
            if (!entity->active || !entity->collides_with_player) continue;
            collidables.insert(entity);
         }
         collision_observer.set_subject(find_0th_entity());
         collision_observer.set_collidables(collidables);
         collision_observer.set_on_test_collide([](void* subject, void* collidable) -> bool {
           return static_cast<Krampus24::Gameplay::Entities::Base*>(subject)->
           collides_aabb3d(static_cast<Krampus24::Gameplay::Entities::Base*>(collidable));
         });
         collision_observer.process();

         // Process "entered" collisions
         for (auto &entered : collision_observer.get_entered())
         {
            // TODO: Consider extracting this to a method
            Krampus24::Gameplay::Entities::Base* entity =
               static_cast<Krampus24::Gameplay::Entities::Base*>(entered);
            // TODO: Add scripting for collecting gems

            // TODO: Incorporate this gem collection logic
            //entity->active = false;
            //entity->visible = false;
            //gems_collected++;
            //entity>on_enter_player_bbox_collision();
            entity->on_enter_player_bbox_collision(player_entity);


            if (scripting && scripting->has_on_collision_callback(entity))
            {
               scripting->call_on_collision_callback(entity);
            }


            if (entity->elevator_shaft__is_elevator_shaft)
            {
               player_entity->attach_to_elevator(entity);
            }


            if (entity->zone__is_zone)
            {
               if (entity->name == "central_column_f1") show_location_name("Central Column", "Floor 1");
               else if (entity->name == "docking_bay") show_location_name("Docking Bay", "Sub Level");
               else if (entity->name == "library") show_location_name("Library", "Floor 1");
               else if (entity->name == "vr_room") show_location_name("VR Room", "Floor 1");
               else if (entity->name == "zoo") show_location_name("Zoo (Farm)", "Floor 1");

               else if (entity->name == "hydroponics_bay") show_location_name("Hydroponics Bay", "Floor 2");
               else if (entity->name == "medical_bay") show_location_name("Medical Bay", "Floor 2");
               else if (entity->name == "mess_hall") show_location_name("Mess Hall", "Floor 2");
               else if (entity->name == "central_column_f2") show_location_name("Central Column", "Floor 2");

               else if (entity->name == "central_column_armory_f3") show_location_name("Armory", "Floor 3");

               else if (entity->name == "central_column_chryo_f4") show_location_name("Cryostasis", "Floor 4");

               else if (entity->name == "central_column_f5") show_location_name("Power Coil Room", "Top Floor");

               else
               {
                  throw std::runtime_error("!!! Unhandled zone name \"" + entity->name + "\"");
               }
            }
         }

         for (auto &exited : collision_observer.get_exited())
         {
            Krampus24::Gameplay::Entities::Base* entity =
               static_cast<Krampus24::Gameplay::Entities::Base*>(exited);
            entity->on_exit_player_bbox_collision();

            if (entity->elevator_shaft__is_elevator_shaft)
            {
               player_entity->detach_from_elevator();
            }
         }
      }


      //
      // Update the position of the camera
      //

      // player_view_camera
      player_view_camera.position = find_0th_entity()->placement.position;
      player_view_camera.position.y += 2.25;
      player_view_camera.stepout = { 0, 0, 0 }; //AllegroFlare::Vec3D(0, 2.25, 0); // FPS camera
      player_view_camera.spin = find_0th_entity()->player__spin;
      player_view_camera.tilt = find_0th_entity()->player__tilt;


      // Use the player_view_camera as the live_camera
      live_camera = player_view_camera;



      //
      // Update player collision events against other object
      // NOTE: This relies on the player_view_camera, so it should be done after updating the camera
      //

      update_inspectable_entity_that_player_is_currently_colliding_with();



      //
      // Evaluate win condition
      //

      if (scripting->end_state_achieved())
      {
         call_on_finished_callback_func();
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::Physics::CollisionMeshCollisionStepper
      - std::get
      - Krampus24::Gameplay::Entities::ElevatorShaft


  - name: render
    body: |
      ALLEGRO_BITMAP *target_bitmap = al_get_target_bitmap();
      live_camera.setup_projection_on(target_bitmap); // TODO: Check if clear color and remove;


      al_clear_to_color(principled_shader.get_fog_color());
      //al_clear_to_color(ALLEGRO_COLOR{0, 0, 0, 1}); // TODO: Check clear to color here



      principled_shader.activate();

      // Draw the visual mesh
      if (rendering_visual_mesh)
      {
         if (visual_mesh)
         {
            visual_mesh->draw();
         }
      }

      // Draw the entities
      if (rendering_entity_models)
      {
         for (auto &entity : entities)
         {
            //entity->draw();
            if (!entity->active) continue;
            if (!entity->visible) continue;

            entity->draw();

            //if (!entity->model) continue;
            //if (entity->texture) entity->model->set_texture(entity->texture);
            //entity->placement.start_transform();
            //entity->model->draw();
            //entity->placement.restore_transform();
         }
      }

      principled_shader.deactivate();

      // TODO: Draw the entities (models?, bounding boxes?)
      if (rendering_entity_bounding_boxes)
      {
         al_set_render_state(ALLEGRO_DEPTH_TEST, 0);
         auto player_entity = find_0th_entity();
         for (auto &entity : entities)
         {
            if (!entity->active || !entity->visible) continue;
            if (entity == player_entity) continue;


            // TODO: Consider that you may wish to draw a box for the model placement(?)
            //// TODO: Remove these lines and have them replaced by entity->draw_aabb3d()
            //std::vector<ALLEGRO_VERTEX> box_line_vertices = entity->build_line_list_vertices();
            //std::vector<ALLEGRO_VERTEX> box_triangle_vertices = entity->build_triangle_list_vertices_for_faces();
            //al_draw_prim(&box_line_vertices[0], nullptr, nullptr, 0, box_line_vertices.size(), ALLEGRO_PRIM_LINE_LIST);
            //al_draw_prim(&box_triangle_vertices[0], nullptr, nullptr, 0, box_triangle_vertices.size(), ALLEGRO_PRIM_TRIANGLE_LIST);


            entity->draw_aabb3d(); // TODO: Have this replace the above legacy code
         }
         al_set_render_state(ALLEGRO_DEPTH_TEST, 1);
      }

      // NOTE: For now, don't clear so that update() (with the legacy classes) has an opportunity to render debug
      // visuals
      if (rendering_collision_wiremesh)
      {
         al_set_render_state(ALLEGRO_DEPTH_TEST, 0);
         if (collision_mesh)
         {
            // TODO: Consider using additive mesh
            collision_mesh->draw(ALLEGRO_COLOR{0.2, 0.2, 0.3, 0.3});
         }
         al_set_render_state(ALLEGRO_DEPTH_TEST, 1);
      }


      hud_camera.setup_dimensional_projection(target_bitmap);

      // TODO: Consider performance implications of clearing the depth buffer here
      al_clear_depth_buffer(1.0);


      // TODO: Consider motion effects for showing/revealing
      if (!get_gameplay_suspended())
      {
         if (showing_inspect_hint)
         {
            al_draw_textf(
               obtain_hud_font(),
               ALLEGRO_COLOR{1, 0.65, 0, 1.0},
               1920-300,
               1080/2,
               ALLEGRO_ALIGN_CENTER,
               "[E] Inspect"
            );

         }


         if (current_location_reveal_counter < 5.0)
         {
            //float reveal_opacity = std::max(current_location_reveal_counter
            
            ALLEGRO_FONT *font = obtain_location_font();
            ALLEGRO_FONT *floor_font = obtain_location_floor_font();
            float y = 1080/5 * 4;
            al_draw_textf(
               font,
               ALLEGRO_COLOR{1.0, 1.0, 1.0, 1.0},
               200, //1920/2,
               y,
               //1920,
               //al_get_font_line_height(font),
               ALLEGRO_ALIGN_LEFT,
               u(current_location_floor).c_str()
            );
            al_draw_textf(
               floor_font,
               ALLEGRO_COLOR{1.0, 1.0, 1.0, 1.0},
               200, //1920/2,
               y + al_get_font_line_height(font),
               //1920,
               //al_get_font_line_height(font),
               ALLEGRO_ALIGN_LEFT,
               u(current_location_name).c_str()
            );

         }


         if (scripting) scripting->render_hud();
      }


      bool drawing_dev_data = false;
      if (drawing_dev_data)
      {
         ALLEGRO_FONT *font = obtain_hud_font();
         float padding = 40;

         al_draw_multiline_textf(
            font,
            ALLEGRO_COLOR{1, 0.65, 0, 1.0},
            padding,
            1080/2,
            1920 - padding * 2,
            al_get_font_line_height(font),
            ALLEGRO_ALIGN_LEFT,
            "str_1: %s\n"
               "float_1: %f\n"
               "float_2: %f\n"
               "float_3: %f\n"
               "float_4: %f\n"
               "bool_1: %i\n",
            dev__str_1.c_str(),
               dev__float_1,
               dev__float_2,
               dev__float_3,
               dev__float_4,
               dev__bool_1
         );
      }


      //ALLEGRO_COLOR col=AllegroFlare::color::azure);
      return;
    body_dependency_symbols:
      - AllegroFlare::Camera3D 



  - name: u
    type: std::string
    parameters:
      - name: string
        type: std::string
        default_argument: '"[unset-string]"'
    body: |
      return AllegroFlare::StringTransformer(string).expand(2).upcase().get_text();
      //return AllegroFlare::StringTransformer(string).expand(2).upcase().get_text();
    body_dependency_symbols:
      - AllegroFlare::StringTransformer



  - name: xxxcall_on_finished_callback_func
    body: |
      // TODO: Test this callback call
      //if (on_finished_callback_func) on_finished_callback_func(this, on_finished_callback_func_user_data);


  - name: game_event_func
    virtual: true
    override: true
    parameters:
      - name: game_event
        type: AllegroFlare::GameEvent*
        default_argument: nullptr
    guards: [ game_event ]
    body: |
      if (scripting) scripting->game_event_func(game_event);
      // game_configuration->handle_game_event(game_event);
      return;


  - name: primary_update_func
    virtual: true
    override: true
    parameters:
      - name: time_now
        type: double
        default_argument: 0.0f
      - name: delta_time
        type: double
        default_argument: 1.0f
    guards: [ initialized ]
    body: |
      AllegroFlare::Screens::Gameplay::primary_update_func(time_now, delta_time);
      // Update stuff here (take into account delta_time)
      update();
      return;


  - name: primary_render_func
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      // Render stuff here
      render();
      return;


  - name: unlock_all_doors
    body: |
      auto as = static_cast<Krampus24::Game::Scripting::Tree*>(scripting);
      as->unlock_mega_door("mega_door.001");
      as->unlock_door("door.003");
      as->unlock_door("door.005");
      as->unlock_sliding_door("sliding_door.001");
      as->unlock_door("door.006");
      as->unlock_sliding_door("sliding_door.002");
      return;


  - name: key_down_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, ev ]
    body: |
      AllegroFlare::Screens::Gameplay::key_down_func(ev);

      bool shift = ev->keyboard.modifiers & ALLEGRO_KEYMOD_SHIFT;
      bool ctrl = ev->keyboard.modifiers & ALLEGRO_KEYMOD_COMMAND;

      //bool keyboard_control_caught = false;
      // This method is DEBUGGING
      switch(ev->keyboard.keycode)
      {
         case ALLEGRO_KEY_W: {
            //toggle_drawing_debug_info();
         } break;

         case ALLEGRO_KEY_A: {
            //toggle_minimap_visibility();
         } break;

         case ALLEGRO_KEY_S: {
            //toggle_minimap_visibility();
         } break;

         case ALLEGRO_KEY_D: {
            //toggle_minimap_visibility();
         } break;

         case ALLEGRO_KEY_J: {
            //live_camera.spin -= ALLEGRO_PI * 0.25;
            //player_spin -= ALLEGRO_PI * 0.25;
         } break;

         case ALLEGRO_KEY_K: {
            //live_camera.spin += ALLEGRO_PI * 0.25;
            //player_spin += ALLEGRO_PI * 0.25;
         } break;

         case ALLEGRO_KEY_U: {
            //live_camera.tilt -= ALLEGRO_PI * 0.125;
         } break;

         case ALLEGRO_KEY_N: {
            //live_camera.tilt += ALLEGRO_PI * 0.125;
         } break;

         // DEVELOPMENT keys

         case ALLEGRO_KEY_0: {
            auto player_entity = find_0th_entity();
            player_entity->placement.position = AllegroFlare::Vec3D(0, 0, 0);
            player_entity->velocity.position = AllegroFlare::Vec3D(0, 0, 0);
         } break;

         case ALLEGRO_KEY_9: {
            auto player_entity = find_0th_entity();
            player_entity->placement.position = player_spawn_position;
            player_entity->velocity.position = AllegroFlare::Vec3D(0, 0, 0);
         } break;

         case ALLEGRO_KEY_L: {
            unlock_all_doors();
         } break;

         case ALLEGRO_KEY_R: {
            if (ctrl)
            {
               std::cout << "> Reload meshes...";
               load_or_reload_meshes();
               std::cout << "done" << std::endl;
            }
         } break;

         case ALLEGRO_KEY_V: {
            rendering_visual_mesh = !rendering_visual_mesh;
         } break;

         case ALLEGRO_KEY_E: {
            if (shift) rendering_entity_bounding_boxes = !rendering_entity_bounding_boxes;
            else
            {
               interact_with_focused_inspectable_object();
            }
         } break;

         case ALLEGRO_KEY_M: {
            rendering_entity_models = !rendering_entity_models;
         } break;

         case ALLEGRO_KEY_C: {
            rendering_collision_wiremesh = !rendering_collision_wiremesh;
         } break;


         //case ALLEGRO_KEY_W:
         //case ALLEGRO_KEY_UP: {
            //player_up_pressed = true;
         //} break;

         //case ALLEGRO_KEY_A:
         //case ALLEGRO_KEY_LEFT: {
            //player_left_pressed = true;
         //} break;

         //case ALLEGRO_KEY_S:
         //case ALLEGRO_KEY_DOWN: {
            //player_down_pressed = true;
         //} break;

         //case ALLEGRO_KEY_D:
         //case ALLEGRO_KEY_RIGHT: {
            //player_right_pressed = true;
         //} break;

         //case ALLEGRO_KEY_C: {
            //set_player_controlled_entity(find_primary_camera());
         //} break;

         //case ALLEGRO_KEY_Q: {
            //keyboard_control_caught = true;
            //set_player_controlled_entity(find_primary_camera());
         //} break;

         //case ALLEGRO_KEY_SPACE:
         //case ALLEGRO_KEY_E:
         //case ALLEGRO_KEY_I: {
            //if (infer_player_controlled_entity_is_camera())
            //{
               //interact_with_focused_object(); // TODO: Find a way to move this to the controller
               //keyboard_control_caught = true;
            //}
         //} break;

         case ALLEGRO_KEY_ESCAPE: {
            // NOTE: For production, you will want to emit the EVENT_PAUSE_GAME. This will crash during test because
            // there is no router. Externally, the body for on_paused_callback might be:
            //event_emitter->emit_router_event(AllegroFlare::Routers::Standard::EVENT_PAUSE_GAME);
            
            // NOTE: For testing, previously the call_on_finished_callback_func was called:
            // call_on_finished_callback_func();

            call_on_paused_callback_func();
            //keyboard_control_caught = true;
         } break;

         default: {
            // Nothing here
         } break;
      }


      //if (player_input_controller_exists())
      //{
         // TODO: Consider that keyboard_control_caught might need to be taken into account
         //get_player_input_controller()->key_down_func(ev);
      //}


      return;
    body_dependency_symbols:
      - AllegroFlare::Routers::Standard
      - AllegroFlare::RouteEventDatas::ActivateScreenByIdentifier
      - AllegroFlare::EventNames


  - name: key_up_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event_emitter ]
    body: |
      AllegroFlare::Screens::Gameplay::key_up_func(ev);

      // This method is DEBUGGING
      switch(ev->keyboard.keycode)
      {
         //case ALLEGRO_KEY_UP:
         //case ALLEGRO_KEY_W: {
            //player_up_pressed = false;
         //} break;

         //case ALLEGRO_KEY_LEFT:
         //case ALLEGRO_KEY_A: {
            //player_left_pressed = false;
         //} break;

         //case ALLEGRO_KEY_DOWN:
         //case ALLEGRO_KEY_S: {
            //player_down_pressed = false;
         //} break;

         //case ALLEGRO_KEY_RIGHT:
         //case ALLEGRO_KEY_D: {
            //player_right_pressed = false;
         //} break;

         default: {
            // Nothing here
         } break;
      }

      //if (player_input_controller_exists())
      //{
         // TODO: Consider that keyboard_control_caught might need to be taken into account
         //get_player_input_controller()->key_up_func(ev);
      //}

      return;
    body_dependency_symbols:
      - AllegroFlare::Routers::Standard
      - AllegroFlare::RouteEventDatas::ActivateScreenByIdentifier
      - AllegroFlare::EventNames


  - name: virtual_control_button_up_func
    virtual: true
    override: true
    parameters:
      - name: player
        type: AllegroFlare::Player*
        default_argument: nullptr
      - name: virtual_controller
        type: AllegroFlare::VirtualControllers::Base*
        default_argument: nullptr
      - name: virtual_controller_button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: false
    guards: [ initialized ]
    body: |
      AllegroFlare::Screens::Gameplay::virtual_control_button_up_func(
         player, virtual_controller, virtual_controller_button_num, is_repeat
      );

      // TODO: this function
      return;


  - name: virtual_control_button_down_func
    virtual: true
    override: true
    parameters:
      - name: player
        type: AllegroFlare::Player*
        default_argument: nullptr
      - name: virtual_controller
        type: AllegroFlare::VirtualControllers::Base*
        default_argument: nullptr
      - name: virtual_controller_button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: false
    guards: [ initialized ]
    body: |
      AllegroFlare::Screens::Gameplay::virtual_control_button_down_func(
         player, virtual_controller, virtual_controller_button_num, is_repeat
      );

      // For now, any button will interact
      //interact_with_focused_inspectable_object();

      // TODO: this function
      //call_on_finished_callback_func(); // Consider technique to exit
      return;


  - name: virtual_control_axis_change_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized ]
    body: |
      // TODO: this function
      return;


  - name: obtain_hud_font
    type: ALLEGRO_FONT*
    body: |
      return font_bin->auto_get("Oswald-Medium.ttf -52");


  - name: obtain_location_font
    type: ALLEGRO_FONT*
    body: |
      return font_bin->auto_get("Michroma-Regular.ttf -48");


  - name: obtain_location_floor_font
    type: ALLEGRO_FONT*
    body: |
      return font_bin->auto_get("Michroma-Regular.ttf -32");


dependencies:


  - symbol: AllegroFlare::AudioController
    headers: [ AllegroFlare/AudioController.hpp ]
  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::Screens::Base
    headers: [ AllegroFlare/Screens/Base.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::ModelBin
    headers: [ AllegroFlare/ModelBin.hpp ]
  - symbol: al_is_primitives_addon_initialized
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: AllegroFlare::Player
    headers: [ AllegroFlare/Player.hpp ]
  - symbol: AllegroFlare::VirtualControllers::Base
    headers: [ AllegroFlare/VirtualControllers/Base.hpp ]
  - symbol: Krampus24::Gameplay::Screen
    headers: [ Krampus24/Gameplay/Screen.hpp ]
  - symbol: AllegroFlare::GameConfigurations::Base
    headers: [ AllegroFlare/GameConfigurations/Base.hpp ]
  - symbol: AllegroFlare::Game::Configurations::Main
    headers: [ AllegroFlare/Game/Configurations/Main.hpp ]
  - symbol: AllegroFlare::Gameplay::Level
    headers: [ AllegroFlare/Gameplay/Level.hpp ]
  - symbol: AllegroFlare::GameEvent
    headers: [ AllegroFlare/GameEvent.hpp ]

  - symbol: AllegroFlare::Physics::CollisionMeshCollisionStepper
    headers: [ AllegroFlare/Physics/CollisionMeshCollisionStepper.hpp ]
  - symbol: AllegroFlare::Camera3D
    headers: [ AllegroFlare/Camera3D.hpp ]
  - symbol: AllegroFlare::Model3D
    headers: [ AllegroFlare/Model3D.hpp ]
  - symbol: std::get
    headers: [ tuple ]
  - symbol: AllegroFlare::Physics::CollisionMesh
    headers: [ AllegroFlare/Physics/CollisionMesh.hpp ]
  - symbol: Krampus24::Gameplay::Entities::Base
    headers: [ Krampus24/Gameplay/Entities/Base.hpp ]
  - symbol: AllegroFlare::Routers::Standard
    headers: [ AllegroFlare/Routers/Standard.hpp ]
  - symbol: AllegroFlare::RouteEventDatas::ActivateScreenByIdentifier
    headers: [ AllegroFlare/RouteEventDatas/ActivateScreenByIdentifier.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::Routers::Standard
    headers: [ AllegroFlare/Routers/Standard.hpp ]
  - symbol: AllegroFlare::RouteEventDatas::ActivateScreenByIdentifier
    headers: [ AllegroFlare/RouteEventDatas/ActivateScreenByIdentifier.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::Screens::Gameplay
    headers: [ AllegroFlare/Screens/Gameplay.hpp ]
  - symbol: AllegroFlare::PlayerInputControllers::Generic
    headers: [ AllegroFlare/PlayerInputControllers/Generic.hpp ]
  - symbol: AllegroFlare::CollisionObservers::Simple
    headers: [ AllegroFlare/CollisionObservers/Simple.hpp ]
  - symbol: AllegroFlare::Camera2D
    headers: [ AllegroFlare/Camera2D.hpp ]
  - symbol: ALLEGRO_FONT
    headers: [ allegro5/allegro_font.h ]
  - symbol: Krampus24::Gameplay::Screen
    headers: [ Krampus24/Gameplay/Screen.hpp ]
  - symbol: AllegroFlare::Vec3D
    headers: [ AllegroFlare/Vec3D.hpp ]
  - symbol: Krampus24::BlenderBlockingLoader
    headers: [ Krampus24/BlenderBlockingLoader.hpp ]
  - symbol: Krampus24::Gameplay::ScriptingInterface
    headers: [ Krampus24/Gameplay/ScriptingInterface.hpp ]
  - symbol: Krampus24::Game::Scripting::Tree
    headers: [ Krampus24/Game/Scripting/Tree.hpp ]
  - symbol: Krampus24::BlenderBlockingLoaderEntity
    headers: [ Krampus24/BlenderBlockingLoaderEntity.hpp ]
  - symbol: Krampus24::Gameplay::Scripting::Empty
    headers: [ Krampus24/Gameplay/Scripting/Empty.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: Krampus24::Gameplay::PlayerInputControllers::Player
    headers: [ Krampus24/Gameplay/PlayerInputControllers/Player.hpp ]
  - symbol: Krampus24::Shaders::Fog
    headers: [ Krampus24/Shaders/Fog.hpp ]
  - symbol: Krampus24::Shaders::Principled
    headers: [ Krampus24/Shaders/Principled.hpp ]
  - symbol: al_color_html
    headers: [ allegro5/allegro_color.h ]
  - symbol: Krampus24::Gameplay::Entities::Base
    headers: [ Krampus24/Gameplay/Entities/Base.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogSystem
    headers: [ AllegroFlare/DialogSystem/DialogSystem.hpp ]
  - symbol: AllegroFlare::StringTransformer
    headers: [ AllegroFlare/StringTransformer.hpp ]
  - symbol: AllegroFlare::Elements::StoryboardPages::Base
    headers: [ AllegroFlare/Elements/StoryboardPages/Base.hpp ]
  - symbol: Krampus24::Game::EntityFactory
    headers: [ Krampus24/Game/EntityFactory.hpp ]
  - symbol: Krampus24::Gameplay::Entities::ElevatorShaft
    headers: [ Krampus24/Gameplay/Entities/ElevatorShaft.hpp ]
  - symbol: Krampus24::Gameplay::Entities::Zone
    headers: [ Krampus24/Gameplay/Entities/Zone.hpp ]
  - symbol: AllegroFlare::distance
    headers: [ AllegroFlare/Useful.hpp ]


